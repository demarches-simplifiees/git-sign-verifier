#!/bin/sh

# Import non-expired GPG keys from a Github username and quick sign them
# so they trusted as commits signatures.

[ $# -ne 1 ] && { echo "Usage: $0 <github-username>"; exit 1; }

USERNAME="$1"
GPG_URL="https://github.com/${USERNAME}.gpg"

echo "Importing GPG keys for: ${USERNAME}"

# Setup temp files
TEMP_KEY=$(mktemp)
TEMP_GPG_HOME=$(mktemp -d)
VALID_KEYS=$(mktemp)
trap "rm -rf ${TEMP_KEY} ${TEMP_GPG_HOME} ${VALID_KEYS}" EXIT

# Download key file
curl -sSL "${GPG_URL}" > "${TEMP_KEY}" || {
    echo "Error: Cannot download GPG key from ${GPG_URL}";
    exit 1;
}

[ ! -s "${TEMP_KEY}" ] && {
    echo "Error: No GPG key found for user ${USERNAME}";
    exit 1;
}

# Import to temp keyring for analysis
gpg --batch --yes --homedir "${TEMP_GPG_HOME}" --import "${TEMP_KEY}" 2>/dev/null

# Filter non-expired keys
CURRENT_TIME=$(date +%s)
echo "Analyzing keys for expiration..."

gpg --homedir "${TEMP_GPG_HOME}" --list-keys --with-colons | while IFS=: read -r -a fields; do
    if [ "${fields[0]}" = "pub" ]; then
        expiration="${fields[6]}"
        # Read next line for fingerprint
        IFS=: read -r -a fpr_fields
        if [ "${fpr_fields[0]}" = "fpr" ]; then
            fingerprint="${fpr_fields[9]}"

            if [ -z "$expiration" ] || [ "$expiration" -gt "$CURRENT_TIME" ]; then
                echo "Valid key: ${fingerprint}"
                echo "$fingerprint" >> "${VALID_KEYS}"
            else
                echo "Skipping expired key: ${fingerprint}"
            fi
        fi
    fi
done

# Import valid keys to main keyring
if [ ! -s "${VALID_KEYS}" ]; then
    echo "No valid keys found to import"
    exit 1
fi

echo "Importing valid keys to main keyring..."
while read -r fingerprint; do
    [ -n "$fingerprint" ] || continue

    echo "Importing: ${fingerprint}"
    gpg --homedir "${TEMP_GPG_HOME}" --export --armor "$fingerprint" | gpg --import 2>/dev/null

    gpg --quick-lsign-key $fingerprint
done < "${VALID_KEYS}"


echo "Done."
